/* Generated by re2c 1.1.1 on Tue Jul 30 23:03:01 2019 */
#line 1 "tok2.re"
#include <stdio.h>

enum num_t { ERR, OP, POW, LE, EQ, GE };

static num_t lex(const char *YYCURSOR)
{
    const char *YYMARKER;
    
#line 12 "tok2.cpp"
{
	char yych;
	yych = *YYCURSOR;
	switch (yych) {
	case '&':
	case '(':
	case ')':
	case '+':
	case ',':
	case '-':
	case '/':
	case '^':
	case '|':
	case '~':	goto yy4;
	case '*':	goto yy6;
	case '<':	goto yy7;
	case '=':	goto yy8;
	case '>':	goto yy9;
	case '@':	goto yy10;
	default:	goto yy2;
	}
yy2:
	++YYCURSOR;
yy3:
#line 30 "tok2.re"
	{ return ERR; }
#line 39 "tok2.cpp"
yy4:
	++YYCURSOR;
yy5:
#line 32 "tok2.re"
	{ return OP; }
#line 45 "tok2.cpp"
yy6:
	yych = *++YYCURSOR;
	switch (yych) {
	case '*':	goto yy10;
	default:	goto yy5;
	}
yy7:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy12;
	default:	goto yy5;
	}
yy8:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy14;
	default:	goto yy3;
	}
yy9:
	yych = *++YYCURSOR;
	switch (yych) {
	case '=':	goto yy16;
	default:	goto yy5;
	}
yy10:
	++YYCURSOR;
#line 33 "tok2.re"
	{ return POW; }
#line 74 "tok2.cpp"
yy12:
	++YYCURSOR;
#line 34 "tok2.re"
	{ return LE; }
#line 79 "tok2.cpp"
yy14:
	++YYCURSOR;
#line 36 "tok2.re"
	{ return EQ; }
#line 84 "tok2.cpp"
yy16:
	++YYCURSOR;
#line 35 "tok2.re"
	{ return GE; }
#line 89 "tok2.cpp"
}
#line 37 "tok2.re"

    /*
        bin end { return BIN; }
        oct end { return OCT; }
        dec end { return DEC; }
        hex end { return HEX; }
    */
        //ident { return IDENTIFIER; }
        //implicitmul { return IMPLICIT_MUL; }
        //numeric { return NUMERIC; }
}

int main(int argc, char **argv)
{
    for (int i = 1; i < argc; ++i) {
        switch (lex(argv[i])) {
            case ERR: printf("error\n"); break;
            case OP: printf("OP\n"); break;
            case POW: printf("POW\n"); break;
            case LE: printf("LE\n"); break;
            case EQ: printf("EQ\n"); break;
            case GE: printf("GE\n"); break;
        }
    }
    return 0;
}
