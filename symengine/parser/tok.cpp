#line 2 "tok.cpp"

#line 4 "tok.cpp"

#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the
 * main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

#define YY_LESS_LINENO(n)
#define YY_LINENO_REWIND_TO(ptr)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                              \
    do {                                                                       \
        /* Undo effects of setting up yytext. */                               \
        int yyless_macro_arg = (n);                                            \
        YY_LESS_LINENO(yyless_macro_arg);                                      \
        *yy_cp = (yy_hold_char);                                               \
        YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp                          \
            = yy_bp + yyless_macro_arg - YY_MORE_ADJ;                          \
        YY_DO_BEFORE_ACTION; /* set up yytext again */                         \
    } while (0)
#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state {
    FILE *yy_input_file;

    char *yy_ch_buf;  /* input buffer */
    char *yy_buf_pos; /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    int yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
/* When an EOF's been seen but there's still some text to process
 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
 * shouldn't try reading from the input source any more.  We might
 * still have a bunch of tokens to match, though, because of
 * possible backing-up.
 *
 * When we actually see the EOF, we change the status to "new"
 * (via yyrestart()), so that the user can continue scanning by
 * just pointing yyin at a new input file.
 */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;          /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;          /**< capacity of stack. */
static YY_BUFFER_STATE *yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER                                                      \
    ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars; /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart(FILE *input_file);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size);
void yy_delete_buffer(YY_BUFFER_STATE b);
void yy_flush_buffer(YY_BUFFER_STATE b);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer);
void yypop_buffer_state(void);

static void yyensure_buffer_stack(void);
static void yy_load_buffer_state(void);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE *file);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER)

YY_BUFFER_STATE yy_scan_buffer(char *base, yy_size_t size);
YY_BUFFER_STATE yy_scan_string(const char *yy_str);
YY_BUFFER_STATE yy_scan_bytes(const char *bytes, int len);

void *yyalloc(yy_size_t);
void *yyrealloc(void *, yy_size_t);
void yyfree(void *);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                     \
    {                                                                          \
        if (!YY_CURRENT_BUFFER) {                                              \
            yyensure_buffer_stack();                                           \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);    \
        }                                                                      \
        YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;          \
    }
#define yy_set_bol(at_bol)                                                     \
    {                                                                          \
        if (!YY_CURRENT_BUFFER) {                                              \
            yyensure_buffer_stack();                                           \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);    \
        }                                                                      \
        YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                          \
    }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

#define yywrap() (/*CONSTCOND*/ 1)
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef const struct yy_trans_info *yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char *yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state(void);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state);
static int yy_get_next_buffer(void);
static void yynoreturn yy_fatal_error(const char *msg);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                    \
    (yytext_ptr) = yy_bp;                                                      \
    yyleng = (int)(yy_cp - yy_bp);                                             \
    (yy_hold_char) = *yy_cp;                                                   \
    *yy_cp = '\0';                                                             \
    (yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 13
#define YY_END_OF_BUFFER 14
struct yy_trans_info {
    flex_int16_t yy_verify;
    flex_int16_t yy_nxt;
};
static const struct yy_trans_info yy_transition[3893] = {
    {0, 0},       {0, 3637},    {0, 0},       {0, 3635},    {1, 516},
    {2, 516},     {3, 516},     {4, 516},     {5, 516},     {6, 516},
    {7, 516},     {8, 516},     {9, 518},     {10, 520},    {11, 516},
    {12, 516},    {13, 516},    {14, 516},    {15, 516},    {16, 516},
    {17, 516},    {18, 516},    {19, 516},    {20, 516},    {21, 516},
    {22, 516},    {23, 516},    {24, 516},    {25, 516},    {26, 516},
    {27, 516},    {28, 516},    {29, 516},    {30, 516},    {31, 516},
    {32, 522},    {33, 516},    {34, 516},    {35, 516},    {36, 516},
    {37, 516},    {38, 524},    {39, 516},    {40, 524},    {41, 524},
    {42, 526},    {43, 524},    {44, 524},    {45, 524},    {46, 528},

    {47, 524},    {48, 540},    {49, 540},    {50, 540},    {51, 540},
    {52, 540},    {53, 540},    {54, 540},    {55, 540},    {56, 540},
    {57, 540},    {58, 516},    {59, 516},    {60, 537},    {61, 542},
    {62, 570},    {63, 516},    {64, 572},    {65, 797},    {66, 797},
    {67, 797},    {68, 797},    {69, 797},    {70, 797},    {71, 797},
    {72, 797},    {73, 797},    {74, 797},    {75, 797},    {76, 797},
    {77, 797},    {78, 797},    {79, 797},    {80, 797},    {81, 797},
    {82, 797},    {83, 797},    {84, 797},    {85, 797},    {86, 797},
    {87, 797},    {88, 797},    {89, 797},    {90, 797},    {91, 516},
    {92, 516},    {93, 516},    {94, 524},    {95, 797},    {96, 516},

    {97, 797},    {98, 797},    {99, 797},    {100, 797},   {101, 797},
    {102, 797},   {103, 797},   {104, 797},   {105, 797},   {106, 797},
    {107, 797},   {108, 797},   {109, 797},   {110, 797},   {111, 797},
    {112, 797},   {113, 797},   {114, 797},   {115, 797},   {116, 797},
    {117, 797},   {118, 797},   {119, 797},   {120, 797},   {121, 797},
    {122, 797},   {123, 516},   {124, 524},   {125, 516},   {126, 524},
    {127, 516},   {128, 797},   {129, 797},   {130, 797},   {131, 797},
    {132, 797},   {133, 797},   {134, 797},   {135, 797},   {136, 797},
    {137, 797},   {138, 797},   {139, 797},   {140, 797},   {141, 797},
    {142, 797},   {143, 797},   {144, 797},   {145, 797},   {146, 797},

    {147, 797},   {148, 797},   {149, 797},   {150, 797},   {151, 797},
    {152, 797},   {153, 797},   {154, 797},   {155, 797},   {156, 797},
    {157, 797},   {158, 797},   {159, 797},   {160, 797},   {161, 797},
    {162, 797},   {163, 797},   {164, 797},   {165, 797},   {166, 797},
    {167, 797},   {168, 797},   {169, 797},   {170, 797},   {171, 797},
    {172, 797},   {173, 797},   {174, 797},   {175, 797},   {176, 797},
    {177, 797},   {178, 797},   {179, 797},   {180, 797},   {181, 797},
    {182, 797},   {183, 797},   {184, 797},   {185, 797},   {186, 797},
    {187, 797},   {188, 797},   {189, 797},   {190, 797},   {191, 797},
    {192, 797},   {193, 797},   {194, 797},   {195, 797},   {196, 797},

    {197, 797},   {198, 797},   {199, 797},   {200, 797},   {201, 797},
    {202, 797},   {203, 797},   {204, 797},   {205, 797},   {206, 797},
    {207, 797},   {208, 797},   {209, 797},   {210, 797},   {211, 797},
    {212, 797},   {213, 797},   {214, 797},   {215, 797},   {216, 797},
    {217, 797},   {218, 797},   {219, 797},   {220, 797},   {221, 797},
    {222, 797},   {223, 797},   {224, 797},   {225, 797},   {226, 797},
    {227, 797},   {228, 797},   {229, 797},   {230, 797},   {231, 797},
    {232, 797},   {233, 797},   {234, 797},   {235, 797},   {236, 797},
    {237, 797},   {238, 797},   {239, 797},   {240, 797},   {241, 797},
    {242, 797},   {243, 797},   {244, 797},   {245, 797},   {246, 797},

    {247, 797},   {248, 797},   {249, 797},   {250, 797},   {251, 797},
    {252, 797},   {253, 797},   {254, 797},   {255, 797},   {256, 516},
    {0, 0},       {0, 3377},    {1, 258},     {2, 258},     {3, 258},
    {4, 258},     {5, 258},     {6, 258},     {7, 258},     {8, 258},
    {9, 260},     {10, 262},    {11, 258},    {12, 258},    {13, 258},
    {14, 258},    {15, 258},    {16, 258},    {17, 258},    {18, 258},
    {19, 258},    {20, 258},    {21, 258},    {22, 258},    {23, 258},
    {24, 258},    {25, 258},    {26, 258},    {27, 258},    {28, 258},
    {29, 258},    {30, 258},    {31, 258},    {32, 264},    {33, 258},
    {34, 258},    {35, 258},    {36, 258},    {37, 258},    {38, 266},

    {39, 258},    {40, 266},    {41, 266},    {42, 268},    {43, 266},
    {44, 266},    {45, 266},    {46, 270},    {47, 266},    {48, 282},
    {49, 282},    {50, 282},    {51, 282},    {52, 282},    {53, 282},
    {54, 282},    {55, 282},    {56, 282},    {57, 282},    {58, 258},
    {59, 258},    {60, 279},    {61, 284},    {62, 312},    {63, 258},
    {64, 314},    {65, 539},    {66, 539},    {67, 539},    {68, 539},
    {69, 539},    {70, 539},    {71, 539},    {72, 539},    {73, 539},
    {74, 539},    {75, 539},    {76, 539},    {77, 539},    {78, 539},
    {79, 539},    {80, 539},    {81, 539},    {82, 539},    {83, 539},
    {84, 539},    {85, 539},    {86, 539},    {87, 539},    {88, 539},

    {89, 539},    {90, 539},    {91, 258},    {92, 258},    {93, 258},
    {94, 266},    {95, 539},    {96, 258},    {97, 539},    {98, 539},
    {99, 539},    {100, 539},   {101, 539},   {102, 539},   {103, 539},
    {104, 539},   {105, 539},   {106, 539},   {107, 539},   {108, 539},
    {109, 539},   {110, 539},   {111, 539},   {112, 539},   {113, 539},
    {114, 539},   {115, 539},   {116, 539},   {117, 539},   {118, 539},
    {119, 539},   {120, 539},   {121, 539},   {122, 539},   {123, 258},
    {124, 266},   {125, 258},   {126, 266},   {127, 258},   {128, 539},
    {129, 539},   {130, 539},   {131, 539},   {132, 539},   {133, 539},
    {134, 539},   {135, 539},   {136, 539},   {137, 539},   {138, 539},

    {139, 539},   {140, 539},   {141, 539},   {142, 539},   {143, 539},
    {144, 539},   {145, 539},   {146, 539},   {147, 539},   {148, 539},
    {149, 539},   {150, 539},   {151, 539},   {152, 539},   {153, 539},
    {154, 539},   {155, 539},   {156, 539},   {157, 539},   {158, 539},
    {159, 539},   {160, 539},   {161, 539},   {162, 539},   {163, 539},
    {164, 539},   {165, 539},   {166, 539},   {167, 539},   {168, 539},
    {169, 539},   {170, 539},   {171, 539},   {172, 539},   {173, 539},
    {174, 539},   {175, 539},   {176, 539},   {177, 539},   {178, 539},
    {179, 539},   {180, 539},   {181, 539},   {182, 539},   {183, 539},
    {184, 539},   {185, 539},   {186, 539},   {187, 539},   {188, 539},

    {189, 539},   {190, 539},   {191, 539},   {192, 539},   {193, 539},
    {194, 539},   {195, 539},   {196, 539},   {197, 539},   {198, 539},
    {199, 539},   {200, 539},   {201, 539},   {202, 539},   {203, 539},
    {204, 539},   {205, 539},   {206, 539},   {207, 539},   {208, 539},
    {209, 539},   {210, 539},   {211, 539},   {212, 539},   {213, 539},
    {214, 539},   {215, 539},   {216, 539},   {217, 539},   {218, 539},
    {219, 539},   {220, 539},   {221, 539},   {222, 539},   {223, 539},
    {224, 539},   {225, 539},   {226, 539},   {227, 539},   {228, 539},
    {229, 539},   {230, 539},   {231, 539},   {232, 539},   {233, 539},
    {234, 539},   {235, 539},   {236, 539},   {237, 539},   {238, 539},

    {239, 539},   {240, 539},   {241, 539},   {242, 539},   {243, 539},
    {244, 539},   {245, 539},   {246, 539},   {247, 539},   {248, 539},
    {249, 539},   {250, 539},   {251, 539},   {252, 539},   {253, 539},
    {254, 539},   {255, 539},   {256, 258},   {0, 12},      {0, 3119},
    {0, 10},      {0, 3117},    {0, 9},       {0, 3115},    {0, 11},
    {0, 3113},    {0, 1},       {0, 3111},    {0, 1},       {0, 3109},
    {0, 12},      {0, 3107},    {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 1},
    {0, 3098},    {0, 0},       {0, 8},       {0, 3095},    {0, 12},
    {0, 3093},    {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {42, 48},     {0, 1},       {0, 3065},    {0, 2},
    {0, 3063},    {0, 2},       {0, 3061},    {0, 0},       {48, 526},
    {49, 526},    {50, 526},    {51, 526},    {52, 526},    {53, 526},
    {54, 526},    {55, 526},    {56, 526},    {57, 526},    {46, 771},
    {0, 0},       {48, 1028},   {49, 1028},   {50, 1028},   {51, 1028},
    {52, 1028},   {53, 1028},   {54, 1028},   {55, 1028},   {56, 1028},

    {57, 1028},   {61, 63},     {0, 3},       {0, 3035},    {0, 5},
    {0, 3033},    {61, 60},     {0, 0},       {65, 1285},   {66, 1285},
    {67, 1285},   {68, 1285},   {69, 1542},   {70, 1285},   {71, 1285},
    {72, 1285},   {73, 1285},   {74, 1285},   {75, 1285},   {76, 1285},
    {77, 1285},   {78, 1285},   {79, 1285},   {80, 1285},   {81, 1285},
    {82, 1285},   {83, 1285},   {84, 1285},   {85, 1285},   {86, 1285},
    {87, 1285},   {88, 1285},   {89, 1285},   {90, 1285},   {61, 63},
    {0, 4},       {0, 3002},    {0, 0},       {95, 1285},   {0, 0},
    {97, 1285},   {98, 1285},   {99, 1285},   {100, 1285},  {101, 1542},
    {102, 1285},  {103, 1285},  {104, 1285},  {105, 1285},  {106, 1285},

    {107, 1285},  {108, 1285},  {109, 1285},  {110, 1285},  {111, 1285},
    {112, 1285},  {113, 1285},  {114, 1285},  {115, 1285},  {116, 1285},
    {117, 1285},  {118, 1285},  {119, 1285},  {120, 1285},  {121, 1285},
    {122, 1285},  {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {128, 1285},  {129, 1285},  {130, 1285},  {131, 1285},
    {132, 1285},  {133, 1285},  {134, 1285},  {135, 1285},  {136, 1285},
    {137, 1285},  {138, 1285},  {139, 1285},  {140, 1285},  {141, 1285},
    {142, 1285},  {143, 1285},  {144, 1285},  {145, 1285},  {146, 1285},
    {147, 1285},  {148, 1285},  {149, 1285},  {150, 1285},  {151, 1285},
    {152, 1285},  {153, 1285},  {154, 1285},  {155, 1285},  {156, 1285},

    {157, 1285},  {158, 1285},  {159, 1285},  {160, 1285},  {161, 1285},
    {162, 1285},  {163, 1285},  {164, 1285},  {165, 1285},  {166, 1285},
    {167, 1285},  {168, 1285},  {169, 1285},  {170, 1285},  {171, 1285},
    {172, 1285},  {173, 1285},  {174, 1285},  {175, 1285},  {176, 1285},
    {177, 1285},  {178, 1285},  {179, 1285},  {180, 1285},  {181, 1285},
    {182, 1285},  {183, 1285},  {184, 1285},  {185, 1285},  {186, 1285},
    {187, 1285},  {188, 1285},  {189, 1285},  {190, 1285},  {191, 1285},
    {192, 1285},  {193, 1285},  {194, 1285},  {195, 1285},  {196, 1285},
    {197, 1285},  {198, 1285},  {199, 1285},  {200, 1285},  {201, 1285},
    {202, 1285},  {203, 1285},  {204, 1285},  {205, 1285},  {206, 1285},

    {207, 1285},  {208, 1285},  {209, 1285},  {210, 1285},  {211, 1285},
    {212, 1285},  {213, 1285},  {214, 1285},  {215, 1285},  {216, 1285},
    {217, 1285},  {218, 1285},  {219, 1285},  {220, 1285},  {221, 1285},
    {222, 1285},  {223, 1285},  {224, 1285},  {225, 1285},  {226, 1285},
    {227, 1285},  {228, 1285},  {229, 1285},  {230, 1285},  {231, 1285},
    {232, 1285},  {233, 1285},  {234, 1285},  {235, 1285},  {236, 1285},
    {237, 1285},  {238, 1285},  {239, 1285},  {240, 1285},  {241, 1285},
    {242, 1285},  {243, 1285},  {244, 1285},  {245, 1285},  {246, 1285},
    {247, 1285},  {248, 1285},  {249, 1285},  {250, 1285},  {251, 1285},
    {252, 1285},  {253, 1285},  {254, 1285},  {255, 1285},  {0, 6},

    {0, 2838},    {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {48, 1542},   {49, 1542},

    {50, 1542},   {51, 1542},   {52, 1542},   {53, 1542},   {54, 1542},
    {55, 1542},   {56, 1542},   {57, 1542},   {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {65, 1542},   {66, 1542},   {67, 1542},   {68, 1542},   {69, 1542},
    {70, 1542},   {71, 1542},   {72, 1542},   {73, 1542},   {74, 1542},
    {75, 1542},   {76, 1542},   {77, 1542},   {78, 1542},   {79, 1542},
    {80, 1542},   {81, 1542},   {82, 1542},   {83, 1542},   {84, 1542},
    {85, 1542},   {86, 1542},   {87, 1542},   {88, 1542},   {89, 1542},
    {90, 1542},   {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {95, 1542},   {0, 0},       {97, 1542},   {98, 1542},   {99, 1542},

    {100, 1542},  {101, 1542},  {102, 1542},  {103, 1542},  {104, 1542},
    {105, 1542},  {106, 1542},  {107, 1542},  {108, 1542},  {109, 1542},
    {110, 1542},  {111, 1542},  {112, 1542},  {113, 1542},  {114, 1542},
    {115, 1542},  {116, 1542},  {117, 1542},  {118, 1542},  {119, 1542},
    {120, 1542},  {121, 1542},  {122, 1542},  {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {128, 1542},  {129, 1542},
    {130, 1542},  {131, 1542},  {132, 1542},  {133, 1542},  {134, 1542},
    {135, 1542},  {136, 1542},  {137, 1542},  {138, 1542},  {139, 1542},
    {140, 1542},  {141, 1542},  {142, 1542},  {143, 1542},  {144, 1542},
    {145, 1542},  {146, 1542},  {147, 1542},  {148, 1542},  {149, 1542},

    {150, 1542},  {151, 1542},  {152, 1542},  {153, 1542},  {154, 1542},
    {155, 1542},  {156, 1542},  {157, 1542},  {158, 1542},  {159, 1542},
    {160, 1542},  {161, 1542},  {162, 1542},  {163, 1542},  {164, 1542},
    {165, 1542},  {166, 1542},  {167, 1542},  {168, 1542},  {169, 1542},
    {170, 1542},  {171, 1542},  {172, 1542},  {173, 1542},  {174, 1542},
    {175, 1542},  {176, 1542},  {177, 1542},  {178, 1542},  {179, 1542},
    {180, 1542},  {181, 1542},  {182, 1542},  {183, 1542},  {184, 1542},
    {185, 1542},  {186, 1542},  {187, 1542},  {188, 1542},  {189, 1542},
    {190, 1542},  {191, 1542},  {192, 1542},  {193, 1542},  {194, 1542},
    {195, 1542},  {196, 1542},  {197, 1542},  {198, 1542},  {199, 1542},

    {200, 1542},  {201, 1542},  {202, 1542},  {203, 1542},  {204, 1542},
    {205, 1542},  {206, 1542},  {207, 1542},  {208, 1542},  {209, 1542},
    {210, 1542},  {211, 1542},  {212, 1542},  {213, 1542},  {214, 1542},
    {215, 1542},  {216, 1542},  {217, 1542},  {218, 1542},  {219, 1542},
    {220, 1542},  {221, 1542},  {222, 1542},  {223, 1542},  {224, 1542},
    {225, 1542},  {226, 1542},  {227, 1542},  {228, 1542},  {229, 1542},
    {230, 1542},  {231, 1542},  {232, 1542},  {233, 1542},  {234, 1542},
    {235, 1542},  {236, 1542},  {237, 1542},  {238, 1542},  {239, 1542},
    {240, 1542},  {241, 1542},  {242, 1542},  {243, 1542},  {244, 1542},
    {245, 1542},  {246, 1542},  {247, 1542},  {248, 1542},  {249, 1542},

    {250, 1542},  {251, 1542},  {252, 1542},  {253, 1542},  {254, 1542},
    {255, 1542},  {0, 8},       {0, 2581},    {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {48, 0},      {49, 0},      {50, 0},      {51, 0},      {52, 0},
    {53, 0},      {54, 0},      {55, 0},      {56, 0},      {57, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {65, 771},    {66, 771},    {67, 771},
    {68, 771},    {69, 1028},   {70, 771},    {71, 771},    {72, 771},
    {73, 771},    {74, 771},    {75, 771},    {76, 771},    {77, 771},
    {78, 771},    {79, 771},    {80, 771},    {81, 771},    {82, 771},
    {83, 771},    {84, 771},    {85, 771},    {86, 771},    {87, 771},
    {88, 771},    {89, 771},    {90, 771},    {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {95, 771},    {0, 0},       {97, 771},
    {98, 771},    {99, 771},    {100, 771},   {101, 1028},  {102, 771},
    {103, 771},   {104, 771},   {105, 771},   {106, 771},   {107, 771},
    {108, 771},   {109, 771},   {110, 771},   {111, 771},   {112, 771},
    {113, 771},   {114, 771},   {115, 771},   {116, 771},   {117, 771},
    {118, 771},   {119, 771},   {120, 771},   {121, 771},   {122, 771},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {128, 771},   {129, 771},   {130, 771},   {131, 771},   {132, 771},
    {133, 771},   {134, 771},   {135, 771},   {136, 771},   {137, 771},
    {138, 771},   {139, 771},   {140, 771},   {141, 771},   {142, 771},

    {143, 771},   {144, 771},   {145, 771},   {146, 771},   {147, 771},
    {148, 771},   {149, 771},   {150, 771},   {151, 771},   {152, 771},
    {153, 771},   {154, 771},   {155, 771},   {156, 771},   {157, 771},
    {158, 771},   {159, 771},   {160, 771},   {161, 771},   {162, 771},
    {163, 771},   {164, 771},   {165, 771},   {166, 771},   {167, 771},
    {168, 771},   {169, 771},   {170, 771},   {171, 771},   {172, 771},
    {173, 771},   {174, 771},   {175, 771},   {176, 771},   {177, 771},
    {178, 771},   {179, 771},   {180, 771},   {181, 771},   {182, 771},
    {183, 771},   {184, 771},   {185, 771},   {186, 771},   {187, 771},
    {188, 771},   {189, 771},   {190, 771},   {191, 771},   {192, 771},

    {193, 771},   {194, 771},   {195, 771},   {196, 771},   {197, 771},
    {198, 771},   {199, 771},   {200, 771},   {201, 771},   {202, 771},
    {203, 771},   {204, 771},   {205, 771},   {206, 771},   {207, 771},
    {208, 771},   {209, 771},   {210, 771},   {211, 771},   {212, 771},
    {213, 771},   {214, 771},   {215, 771},   {216, 771},   {217, 771},
    {218, 771},   {219, 771},   {220, 771},   {221, 771},   {222, 771},
    {223, 771},   {224, 771},   {225, 771},   {226, 771},   {227, 771},
    {228, 771},   {229, 771},   {230, 771},   {231, 771},   {232, 771},
    {233, 771},   {234, 771},   {235, 771},   {236, 771},   {237, 771},
    {238, 771},   {239, 771},   {240, 771},   {241, 771},   {242, 771},

    {243, 771},   {244, 771},   {245, 771},   {246, 771},   {247, 771},
    {248, 771},   {249, 771},   {250, 771},   {251, 771},   {252, 771},
    {253, 771},   {254, 771},   {255, 771},   {0, 8},       {0, 2324},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {48, -257},   {49, -257},   {50, -257},
    {51, -257},   {52, -257},   {53, -257},   {54, -257},   {55, -257},
    {56, -257},   {57, -257},   {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {65, 514},
    {66, 514},    {67, 514},    {68, 514},    {69, 514},    {70, 514},
    {71, 514},    {72, 514},    {73, 514},    {74, 514},    {75, 514},
    {76, 514},    {77, 514},    {78, 514},    {79, 514},    {80, 514},
    {81, 514},    {82, 514},    {83, 514},    {84, 514},    {85, 514},

    {86, 514},    {87, 514},    {88, 514},    {89, 514},    {90, 514},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {95, 514},
    {0, 0},       {97, 514},    {98, 514},    {99, 514},    {100, 514},
    {101, 514},   {102, 514},   {103, 514},   {104, 514},   {105, 514},
    {106, 514},   {107, 514},   {108, 514},   {109, 514},   {110, 514},
    {111, 514},   {112, 514},   {113, 514},   {114, 514},   {115, 514},
    {116, 514},   {117, 514},   {118, 514},   {119, 514},   {120, 514},
    {121, 514},   {122, 514},   {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {128, 514},   {129, 514},   {130, 514},
    {131, 514},   {132, 514},   {133, 514},   {134, 514},   {135, 514},

    {136, 514},   {137, 514},   {138, 514},   {139, 514},   {140, 514},
    {141, 514},   {142, 514},   {143, 514},   {144, 514},   {145, 514},
    {146, 514},   {147, 514},   {148, 514},   {149, 514},   {150, 514},
    {151, 514},   {152, 514},   {153, 514},   {154, 514},   {155, 514},
    {156, 514},   {157, 514},   {158, 514},   {159, 514},   {160, 514},
    {161, 514},   {162, 514},   {163, 514},   {164, 514},   {165, 514},
    {166, 514},   {167, 514},   {168, 514},   {169, 514},   {170, 514},
    {171, 514},   {172, 514},   {173, 514},   {174, 514},   {175, 514},
    {176, 514},   {177, 514},   {178, 514},   {179, 514},   {180, 514},
    {181, 514},   {182, 514},   {183, 514},   {184, 514},   {185, 514},

    {186, 514},   {187, 514},   {188, 514},   {189, 514},   {190, 514},
    {191, 514},   {192, 514},   {193, 514},   {194, 514},   {195, 514},
    {196, 514},   {197, 514},   {198, 514},   {199, 514},   {200, 514},
    {201, 514},   {202, 514},   {203, 514},   {204, 514},   {205, 514},
    {206, 514},   {207, 514},   {208, 514},   {209, 514},   {210, 514},
    {211, 514},   {212, 514},   {213, 514},   {214, 514},   {215, 514},
    {216, 514},   {217, 514},   {218, 514},   {219, 514},   {220, 514},
    {221, 514},   {222, 514},   {223, 514},   {224, 514},   {225, 514},
    {226, 514},   {227, 514},   {228, 514},   {229, 514},   {230, 514},
    {231, 514},   {232, 514},   {233, 514},   {234, 514},   {235, 514},

    {236, 514},   {237, 514},   {238, 514},   {239, 514},   {240, 514},
    {241, 514},   {242, 514},   {243, 514},   {244, 514},   {245, 514},
    {246, 514},   {247, 514},   {248, 514},   {249, 514},   {250, 514},
    {251, 514},   {252, 514},   {253, 514},   {254, 514},   {255, 514},
    {0, 8},       {0, 2067},    {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {46, -257},   {0, 0},       {48, 0},
    {49, 0},      {50, 0},      {51, 0},      {52, 0},      {53, 0},
    {54, 0},      {55, 0},      {56, 0},      {57, 0},      {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {65, 257},    {66, 257},    {67, 257},    {68, 257},
    {69, 514},    {70, 257},    {71, 257},    {72, 257},    {73, 257},
    {74, 257},    {75, 257},    {76, 257},    {77, 257},    {78, 257},

    {79, 257},    {80, 257},    {81, 257},    {82, 257},    {83, 257},
    {84, 257},    {85, 257},    {86, 257},    {87, 257},    {88, 257},
    {89, 257},    {90, 257},    {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {95, 257},    {0, 0},       {97, 257},    {98, 257},
    {99, 257},    {100, 257},   {101, 514},   {102, 257},   {103, 257},
    {104, 257},   {105, 257},   {106, 257},   {107, 257},   {108, 257},
    {109, 257},   {110, 257},   {111, 257},   {112, 257},   {113, 257},
    {114, 257},   {115, 257},   {116, 257},   {117, 257},   {118, 257},
    {119, 257},   {120, 257},   {121, 257},   {122, 257},   {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {128, 257},

    {129, 257},   {130, 257},   {131, 257},   {132, 257},   {133, 257},
    {134, 257},   {135, 257},   {136, 257},   {137, 257},   {138, 257},
    {139, 257},   {140, 257},   {141, 257},   {142, 257},   {143, 257},
    {144, 257},   {145, 257},   {146, 257},   {147, 257},   {148, 257},
    {149, 257},   {150, 257},   {151, 257},   {152, 257},   {153, 257},
    {154, 257},   {155, 257},   {156, 257},   {157, 257},   {158, 257},
    {159, 257},   {160, 257},   {161, 257},   {162, 257},   {163, 257},
    {164, 257},   {165, 257},   {166, 257},   {167, 257},   {168, 257},
    {169, 257},   {170, 257},   {171, 257},   {172, 257},   {173, 257},
    {174, 257},   {175, 257},   {176, 257},   {177, 257},   {178, 257},

    {179, 257},   {180, 257},   {181, 257},   {182, 257},   {183, 257},
    {184, 257},   {185, 257},   {186, 257},   {187, 257},   {188, 257},
    {189, 257},   {190, 257},   {191, 257},   {192, 257},   {193, 257},
    {194, 257},   {195, 257},   {196, 257},   {197, 257},   {198, 257},
    {199, 257},   {200, 257},   {201, 257},   {202, 257},   {203, 257},
    {204, 257},   {205, 257},   {206, 257},   {207, 257},   {208, 257},
    {209, 257},   {210, 257},   {211, 257},   {212, 257},   {213, 257},
    {214, 257},   {215, 257},   {216, 257},   {217, 257},   {218, 257},
    {219, 257},   {220, 257},   {221, 257},   {222, 257},   {223, 257},
    {224, 257},   {225, 257},   {226, 257},   {227, 257},   {228, 257},

    {229, 257},   {230, 257},   {231, 257},   {232, 257},   {233, 257},
    {234, 257},   {235, 257},   {236, 257},   {237, 257},   {238, 257},
    {239, 257},   {240, 257},   {241, 257},   {242, 257},   {243, 257},
    {244, 257},   {245, 257},   {246, 257},   {247, 257},   {248, 257},
    {249, 257},   {250, 257},   {251, 257},   {252, 257},   {253, 257},
    {254, 257},   {255, 257},   {0, 7},       {0, 1810},    {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {48, 771},    {49, 771},    {50, 771},    {51, 771},
    {52, 771},    {53, 771},    {54, 771},    {55, 771},    {56, 771},
    {57, 771},    {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {65, 771},    {66, 771},
    {67, 771},    {68, 771},    {69, 771},    {70, 771},    {71, 771},

    {72, 771},    {73, 771},    {74, 771},    {75, 771},    {76, 771},
    {77, 771},    {78, 771},    {79, 771},    {80, 771},    {81, 771},
    {82, 771},    {83, 771},    {84, 771},    {85, 771},    {86, 771},
    {87, 771},    {88, 771},    {89, 771},    {90, 771},    {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {95, 771},    {0, 0},
    {97, 771},    {98, 771},    {99, 771},    {100, 771},   {101, 771},
    {102, 771},   {103, 771},   {104, 771},   {105, 771},   {106, 771},
    {107, 771},   {108, 771},   {109, 771},   {110, 771},   {111, 771},
    {112, 771},   {113, 771},   {114, 771},   {115, 771},   {116, 771},
    {117, 771},   {118, 771},   {119, 771},   {120, 771},   {121, 771},

    {122, 771},   {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {128, 771},   {129, 771},   {130, 771},   {131, 771},
    {132, 771},   {133, 771},   {134, 771},   {135, 771},   {136, 771},
    {137, 771},   {138, 771},   {139, 771},   {140, 771},   {141, 771},
    {142, 771},   {143, 771},   {144, 771},   {145, 771},   {146, 771},
    {147, 771},   {148, 771},   {149, 771},   {150, 771},   {151, 771},
    {152, 771},   {153, 771},   {154, 771},   {155, 771},   {156, 771},
    {157, 771},   {158, 771},   {159, 771},   {160, 771},   {161, 771},
    {162, 771},   {163, 771},   {164, 771},   {165, 771},   {166, 771},
    {167, 771},   {168, 771},   {169, 771},   {170, 771},   {171, 771},

    {172, 771},   {173, 771},   {174, 771},   {175, 771},   {176, 771},
    {177, 771},   {178, 771},   {179, 771},   {180, 771},   {181, 771},
    {182, 771},   {183, 771},   {184, 771},   {185, 771},   {186, 771},
    {187, 771},   {188, 771},   {189, 771},   {190, 771},   {191, 771},
    {192, 771},   {193, 771},   {194, 771},   {195, 771},   {196, 771},
    {197, 771},   {198, 771},   {199, 771},   {200, 771},   {201, 771},
    {202, 771},   {203, 771},   {204, 771},   {205, 771},   {206, 771},
    {207, 771},   {208, 771},   {209, 771},   {210, 771},   {211, 771},
    {212, 771},   {213, 771},   {214, 771},   {215, 771},   {216, 771},
    {217, 771},   {218, 771},   {219, 771},   {220, 771},   {221, 771},

    {222, 771},   {223, 771},   {224, 771},   {225, 771},   {226, 771},
    {227, 771},   {228, 771},   {229, 771},   {230, 771},   {231, 771},
    {232, 771},   {233, 771},   {234, 771},   {235, 771},   {236, 771},
    {237, 771},   {238, 771},   {239, 771},   {240, 771},   {241, 771},
    {242, 771},   {243, 771},   {244, 771},   {245, 771},   {246, 771},
    {247, 771},   {248, 771},   {249, 771},   {250, 771},   {251, 771},
    {252, 771},   {253, 771},   {254, 771},   {255, 771},   {0, 7},
    {0, 1553},    {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {43, 771},    {0, 0},
    {45, 771},    {0, 0},       {0, 0},       {48, 781},    {49, 781},
    {50, 781},    {51, 781},    {52, 781},    {53, 781},    {54, 781},
    {55, 781},    {56, 781},    {57, 781},    {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {65, 514},    {66, 514},    {67, 514},    {68, 514},    {69, 514},
    {70, 514},    {71, 514},    {72, 514},    {73, 514},    {74, 514},
    {75, 514},    {76, 514},    {77, 514},    {78, 514},    {79, 514},
    {80, 514},    {81, 514},    {82, 514},    {83, 514},    {84, 514},
    {85, 514},    {86, 514},    {87, 514},    {88, 514},    {89, 514},
    {90, 514},    {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {95, 514},    {0, 0},       {97, 514},    {98, 514},    {99, 514},
    {100, 514},   {101, 514},   {102, 514},   {103, 514},   {104, 514},
    {105, 514},   {106, 514},   {107, 514},   {108, 514},   {109, 514},
    {110, 514},   {111, 514},   {112, 514},   {113, 514},   {114, 514},

    {115, 514},   {116, 514},   {117, 514},   {118, 514},   {119, 514},
    {120, 514},   {121, 514},   {122, 514},   {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {128, 514},   {129, 514},
    {130, 514},   {131, 514},   {132, 514},   {133, 514},   {134, 514},
    {135, 514},   {136, 514},   {137, 514},   {138, 514},   {139, 514},
    {140, 514},   {141, 514},   {142, 514},   {143, 514},   {144, 514},
    {145, 514},   {146, 514},   {147, 514},   {148, 514},   {149, 514},
    {150, 514},   {151, 514},   {152, 514},   {153, 514},   {154, 514},
    {155, 514},   {156, 514},   {157, 514},   {158, 514},   {159, 514},
    {160, 514},   {161, 514},   {162, 514},   {163, 514},   {164, 514},

    {165, 514},   {166, 514},   {167, 514},   {168, 514},   {169, 514},
    {170, 514},   {171, 514},   {172, 514},   {173, 514},   {174, 514},
    {175, 514},   {176, 514},   {177, 514},   {178, 514},   {179, 514},
    {180, 514},   {181, 514},   {182, 514},   {183, 514},   {184, 514},
    {185, 514},   {186, 514},   {187, 514},   {188, 514},   {189, 514},
    {190, 514},   {191, 514},   {192, 514},   {193, 514},   {194, 514},
    {195, 514},   {196, 514},   {197, 514},   {198, 514},   {199, 514},
    {200, 514},   {201, 514},   {202, 514},   {203, 514},   {204, 514},
    {205, 514},   {206, 514},   {207, 514},   {208, 514},   {209, 514},
    {210, 514},   {211, 514},   {212, 514},   {213, 514},   {214, 514},

    {215, 514},   {216, 514},   {217, 514},   {218, 514},   {219, 514},
    {220, 514},   {221, 514},   {222, 514},   {223, 514},   {224, 514},
    {225, 514},   {226, 514},   {227, 514},   {228, 514},   {229, 514},
    {230, 514},   {231, 514},   {232, 514},   {233, 514},   {234, 514},
    {235, 514},   {236, 514},   {237, 514},   {238, 514},   {239, 514},
    {240, 514},   {241, 514},   {242, 514},   {243, 514},   {244, 514},
    {245, 514},   {246, 514},   {247, 514},   {248, 514},   {249, 514},
    {250, 514},   {251, 514},   {252, 514},   {253, 514},   {254, 514},
    {255, 514},   {0, 6},       {0, 1296},    {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {48, 0},      {49, 0},      {50, 0},      {51, 0},      {52, 0},
    {53, 0},      {54, 0},      {55, 0},      {56, 0},      {57, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {65, 0},      {66, 0},      {67, 0},
    {68, 0},      {69, 0},      {70, 0},      {71, 0},      {72, 0},
    {73, 0},      {74, 0},      {75, 0},      {76, 0},      {77, 0},
    {78, 0},      {79, 0},      {80, 0},      {81, 0},      {82, 0},
    {83, 0},      {84, 0},      {85, 0},      {86, 0},      {87, 0},
    {88, 0},      {89, 0},      {90, 0},      {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {95, 0},      {0, 0},       {97, 0},
    {98, 0},      {99, 0},      {100, 0},     {101, 0},     {102, 0},
    {103, 0},     {104, 0},     {105, 0},     {106, 0},     {107, 0},

    {108, 0},     {109, 0},     {110, 0},     {111, 0},     {112, 0},
    {113, 0},     {114, 0},     {115, 0},     {116, 0},     {117, 0},
    {118, 0},     {119, 0},     {120, 0},     {121, 0},     {122, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {128, 0},     {129, 0},     {130, 0},     {131, 0},     {132, 0},
    {133, 0},     {134, 0},     {135, 0},     {136, 0},     {137, 0},
    {138, 0},     {139, 0},     {140, 0},     {141, 0},     {142, 0},
    {143, 0},     {144, 0},     {145, 0},     {146, 0},     {147, 0},
    {148, 0},     {149, 0},     {150, 0},     {151, 0},     {152, 0},
    {153, 0},     {154, 0},     {155, 0},     {156, 0},     {157, 0},

    {158, 0},     {159, 0},     {160, 0},     {161, 0},     {162, 0},
    {163, 0},     {164, 0},     {165, 0},     {166, 0},     {167, 0},
    {168, 0},     {169, 0},     {170, 0},     {171, 0},     {172, 0},
    {173, 0},     {174, 0},     {175, 0},     {176, 0},     {177, 0},
    {178, 0},     {179, 0},     {180, 0},     {181, 0},     {182, 0},
    {183, 0},     {184, 0},     {185, 0},     {186, 0},     {187, 0},
    {188, 0},     {189, 0},     {190, 0},     {191, 0},     {192, 0},
    {193, 0},     {194, 0},     {195, 0},     {196, 0},     {197, 0},
    {198, 0},     {199, 0},     {200, 0},     {201, 0},     {202, 0},
    {203, 0},     {204, 0},     {205, 0},     {206, 0},     {207, 0},

    {208, 0},     {209, 0},     {210, 0},     {211, 0},     {212, 0},
    {213, 0},     {214, 0},     {215, 0},     {216, 0},     {217, 0},
    {218, 0},     {219, 0},     {220, 0},     {221, 0},     {222, 0},
    {223, 0},     {224, 0},     {225, 0},     {226, 0},     {227, 0},
    {228, 0},     {229, 0},     {230, 0},     {231, 0},     {232, 0},
    {233, 0},     {234, 0},     {235, 0},     {236, 0},     {237, 0},
    {238, 0},     {239, 0},     {240, 0},     {241, 0},     {242, 0},
    {243, 0},     {244, 0},     {245, 0},     {246, 0},     {247, 0},
    {248, 0},     {249, 0},     {250, 0},     {251, 0},     {252, 0},
    {253, 0},     {254, 0},     {255, 0},     {0, 7},       {0, 1039},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {48, 0},      {49, 0},      {50, 0},

    {51, 0},      {52, 0},      {53, 0},      {54, 0},      {55, 0},
    {56, 0},      {57, 0},      {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {65, 0},
    {66, 0},      {67, 0},      {68, 0},      {69, 0},      {70, 0},
    {71, 0},      {72, 0},      {73, 0},      {74, 0},      {75, 0},
    {76, 0},      {77, 0},      {78, 0},      {79, 0},      {80, 0},
    {81, 0},      {82, 0},      {83, 0},      {84, 0},      {85, 0},
    {86, 0},      {87, 0},      {88, 0},      {89, 0},      {90, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {95, 0},
    {0, 0},       {97, 0},      {98, 0},      {99, 0},      {100, 0},

    {101, 0},     {102, 0},     {103, 0},     {104, 0},     {105, 0},
    {106, 0},     {107, 0},     {108, 0},     {109, 0},     {110, 0},
    {111, 0},     {112, 0},     {113, 0},     {114, 0},     {115, 0},
    {116, 0},     {117, 0},     {118, 0},     {119, 0},     {120, 0},
    {121, 0},     {122, 0},     {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {128, 0},     {129, 0},     {130, 0},
    {131, 0},     {132, 0},     {133, 0},     {134, 0},     {135, 0},
    {136, 0},     {137, 0},     {138, 0},     {139, 0},     {140, 0},
    {141, 0},     {142, 0},     {143, 0},     {144, 0},     {145, 0},
    {146, 0},     {147, 0},     {148, 0},     {149, 0},     {150, 0},

    {151, 0},     {152, 0},     {153, 0},     {154, 0},     {155, 0},
    {156, 0},     {157, 0},     {158, 0},     {159, 0},     {160, 0},
    {161, 0},     {162, 0},     {163, 0},     {164, 0},     {165, 0},
    {166, 0},     {167, 0},     {168, 0},     {169, 0},     {170, 0},
    {171, 0},     {172, 0},     {173, 0},     {174, 0},     {175, 0},
    {176, 0},     {177, 0},     {178, 0},     {179, 0},     {180, 0},
    {181, 0},     {182, 0},     {183, 0},     {184, 0},     {185, 0},
    {186, 0},     {187, 0},     {188, 0},     {189, 0},     {190, 0},
    {191, 0},     {192, 0},     {193, 0},     {194, 0},     {195, 0},
    {196, 0},     {197, 0},     {198, 0},     {199, 0},     {200, 0},

    {201, 0},     {202, 0},     {203, 0},     {204, 0},     {205, 0},
    {206, 0},     {207, 0},     {208, 0},     {209, 0},     {210, 0},
    {211, 0},     {212, 0},     {213, 0},     {214, 0},     {215, 0},
    {216, 0},     {217, 0},     {218, 0},     {219, 0},     {220, 0},
    {221, 0},     {222, 0},     {223, 0},     {224, 0},     {225, 0},
    {226, 0},     {227, 0},     {228, 0},     {229, 0},     {230, 0},
    {231, 0},     {232, 0},     {233, 0},     {234, 0},     {235, 0},
    {236, 0},     {237, 0},     {238, 0},     {239, 0},     {240, 0},
    {241, 0},     {242, 0},     {243, 0},     {244, 0},     {245, 0},
    {246, 0},     {247, 0},     {248, 0},     {249, 0},     {250, 0},

    {251, 0},     {252, 0},     {253, 0},     {254, 0},     {255, 0},
    {0, 0},       {0, 782},     {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 7},       {0, 772},     {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {48, 267},
    {49, 267},    {50, 267},    {51, 267},    {52, 267},    {53, 267},
    {54, 267},    {55, 267},    {56, 267},    {57, 267},    {48, 0},
    {49, 0},      {50, 0},      {51, 0},      {52, 0},      {53, 0},
    {54, 0},      {55, 0},      {56, 0},      {57, 0},      {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {65, 514},    {66, 514},    {67, 514},    {68, 514},
    {69, 514},    {70, 514},    {71, 514},    {72, 514},    {73, 514},
    {74, 514},    {75, 514},    {76, 514},    {77, 514},    {78, 514},
    {79, 514},    {80, 514},    {81, 514},    {82, 514},    {83, 514},

    {84, 514},    {85, 514},    {86, 514},    {87, 514},    {88, 514},
    {89, 514},    {90, 514},    {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {95, 514},    {0, 0},       {97, 514},    {98, 514},
    {99, 514},    {100, 514},   {101, 514},   {102, 514},   {103, 514},
    {104, 514},   {105, 514},   {106, 514},   {107, 514},   {108, 514},
    {109, 514},   {110, 514},   {111, 514},   {112, 514},   {113, 514},
    {114, 514},   {115, 514},   {116, 514},   {117, 514},   {118, 514},
    {119, 514},   {120, 514},   {121, 514},   {122, 514},   {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {128, 514},
    {129, 514},   {130, 514},   {131, 514},   {132, 514},   {133, 514},

    {134, 514},   {135, 514},   {136, 514},   {137, 514},   {138, 514},
    {139, 514},   {140, 514},   {141, 514},   {142, 514},   {143, 514},
    {144, 514},   {145, 514},   {146, 514},   {147, 514},   {148, 514},
    {149, 514},   {150, 514},   {151, 514},   {152, 514},   {153, 514},
    {154, 514},   {155, 514},   {156, 514},   {157, 514},   {158, 514},
    {159, 514},   {160, 514},   {161, 514},   {162, 514},   {163, 514},
    {164, 514},   {165, 514},   {166, 514},   {167, 514},   {168, 514},
    {169, 514},   {170, 514},   {171, 514},   {172, 514},   {173, 514},
    {174, 514},   {175, 514},   {176, 514},   {177, 514},   {178, 514},
    {179, 514},   {180, 514},   {181, 514},   {182, 514},   {183, 514},

    {184, 514},   {185, 514},   {186, 514},   {187, 514},   {188, 514},
    {189, 514},   {190, 514},   {191, 514},   {192, 514},   {193, 514},
    {194, 514},   {195, 514},   {196, 514},   {197, 514},   {198, 514},
    {199, 514},   {200, 514},   {201, 514},   {202, 514},   {203, 514},
    {204, 514},   {205, 514},   {206, 514},   {207, 514},   {208, 514},
    {209, 514},   {210, 514},   {211, 514},   {212, 514},   {213, 514},
    {214, 514},   {215, 514},   {216, 514},   {217, 514},   {218, 514},
    {219, 514},   {220, 514},   {221, 514},   {222, 514},   {223, 514},
    {224, 514},   {225, 514},   {226, 514},   {227, 514},   {228, 514},
    {229, 514},   {230, 514},   {231, 514},   {232, 514},   {233, 514},

    {234, 514},   {235, 514},   {236, 514},   {237, 514},   {238, 514},
    {239, 514},   {240, 514},   {241, 514},   {242, 514},   {243, 514},
    {244, 514},   {245, 514},   {246, 514},   {247, 514},   {248, 514},
    {249, 514},   {250, 514},   {251, 514},   {252, 514},   {253, 514},
    {254, 514},   {255, 514},   {0, 8},       {0, 515},     {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {48, 0},      {49, 0},      {50, 0},      {51, 0},
    {52, 0},      {53, 0},      {54, 0},      {55, 0},      {56, 0},
    {57, 0},      {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {65, -1295},  {66, -1295},
    {67, -1295},  {68, -1295},  {69, -1295},  {70, -1295},  {71, -1295},
    {72, -1295},  {73, -1295},  {74, -1295},  {75, -1295},  {76, -1295},

    {77, -1295},  {78, -1295},  {79, -1295},  {80, -1295},  {81, -1295},
    {82, -1295},  {83, -1295},  {84, -1295},  {85, -1295},  {86, -1295},
    {87, -1295},  {88, -1295},  {89, -1295},  {90, -1295},  {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {95, -1295},  {0, 0},
    {97, -1295},  {98, -1295},  {99, -1295},  {100, -1295}, {101, -1295},
    {102, -1295}, {103, -1295}, {104, -1295}, {105, -1295}, {106, -1295},
    {107, -1295}, {108, -1295}, {109, -1295}, {110, -1295}, {111, -1295},
    {112, -1295}, {113, -1295}, {114, -1295}, {115, -1295}, {116, -1295},
    {117, -1295}, {118, -1295}, {119, -1295}, {120, -1295}, {121, -1295},
    {122, -1295}, {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {128, -1295}, {129, -1295}, {130, -1295}, {131, -1295},
    {132, -1295}, {133, -1295}, {134, -1295}, {135, -1295}, {136, -1295},
    {137, -1295}, {138, -1295}, {139, -1295}, {140, -1295}, {141, -1295},
    {142, -1295}, {143, -1295}, {144, -1295}, {145, -1295}, {146, -1295},
    {147, -1295}, {148, -1295}, {149, -1295}, {150, -1295}, {151, -1295},
    {152, -1295}, {153, -1295}, {154, -1295}, {155, -1295}, {156, -1295},
    {157, -1295}, {158, -1295}, {159, -1295}, {160, -1295}, {161, -1295},
    {162, -1295}, {163, -1295}, {164, -1295}, {165, -1295}, {166, -1295},
    {167, -1295}, {168, -1295}, {169, -1295}, {170, -1295}, {171, -1295},
    {172, -1295}, {173, -1295}, {174, -1295}, {175, -1295}, {176, -1295},

    {177, -1295}, {178, -1295}, {179, -1295}, {180, -1295}, {181, -1295},
    {182, -1295}, {183, -1295}, {184, -1295}, {185, -1295}, {186, -1295},
    {187, -1295}, {188, -1295}, {189, -1295}, {190, -1295}, {191, -1295},
    {192, -1295}, {193, -1295}, {194, -1295}, {195, -1295}, {196, -1295},
    {197, -1295}, {198, -1295}, {199, -1295}, {200, -1295}, {201, -1295},
    {202, -1295}, {203, -1295}, {204, -1295}, {205, -1295}, {206, -1295},
    {207, -1295}, {208, -1295}, {209, -1295}, {210, -1295}, {211, -1295},
    {212, -1295}, {213, -1295}, {214, -1295}, {215, -1295}, {216, -1295},
    {217, -1295}, {218, -1295}, {219, -1295}, {220, -1295}, {221, -1295},
    {222, -1295}, {223, -1295}, {224, -1295}, {225, -1295}, {226, -1295},

    {227, -1295}, {228, -1295}, {229, -1295}, {230, -1295}, {231, -1295},
    {232, -1295}, {233, -1295}, {234, -1295}, {235, -1295}, {236, -1295},
    {237, -1295}, {238, -1295}, {239, -1295}, {240, -1295}, {241, -1295},
    {242, -1295}, {243, -1295}, {244, -1295}, {245, -1295}, {246, -1295},
    {247, -1295}, {248, -1295}, {249, -1295}, {250, -1295}, {251, -1295},
    {252, -1295}, {253, -1295}, {254, -1295}, {255, -1295}, {0, 7},
    {0, 258},     {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},

    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {48, -781},   {49, -781},
    {50, -781},   {51, -781},   {52, -781},   {53, -781},   {54, -781},
    {55, -781},   {56, -781},   {57, -781},   {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {65, -781},   {66, -781},   {67, -781},   {68, -781},   {69, -781},

    {70, -781},   {71, -781},   {72, -781},   {73, -781},   {74, -781},
    {75, -781},   {76, -781},   {77, -781},   {78, -781},   {79, -781},
    {80, -781},   {81, -781},   {82, -781},   {83, -781},   {84, -781},
    {85, -781},   {86, -781},   {87, -781},   {88, -781},   {89, -781},
    {90, -781},   {0, 0},       {0, 0},       {0, 0},       {0, 0},
    {95, -781},   {0, 0},       {97, -781},   {98, -781},   {99, -781},
    {100, -781},  {101, -781},  {102, -781},  {103, -781},  {104, -781},
    {105, -781},  {106, -781},  {107, -781},  {108, -781},  {109, -781},
    {110, -781},  {111, -781},  {112, -781},  {113, -781},  {114, -781},
    {115, -781},  {116, -781},  {117, -781},  {118, -781},  {119, -781},

    {120, -781},  {121, -781},  {122, -781},  {0, 0},       {0, 0},
    {0, 0},       {0, 0},       {0, 0},       {128, -781},  {129, -781},
    {130, -781},  {131, -781},  {132, -781},  {133, -781},  {134, -781},
    {135, -781},  {136, -781},  {137, -781},  {138, -781},  {139, -781},
    {140, -781},  {141, -781},  {142, -781},  {143, -781},  {144, -781},
    {145, -781},  {146, -781},  {147, -781},  {148, -781},  {149, -781},
    {150, -781},  {151, -781},  {152, -781},  {153, -781},  {154, -781},
    {155, -781},  {156, -781},  {157, -781},  {158, -781},  {159, -781},
    {160, -781},  {161, -781},  {162, -781},  {163, -781},  {164, -781},
    {165, -781},  {166, -781},  {167, -781},  {168, -781},  {169, -781},

    {170, -781},  {171, -781},  {172, -781},  {173, -781},  {174, -781},
    {175, -781},  {176, -781},  {177, -781},  {178, -781},  {179, -781},
    {180, -781},  {181, -781},  {182, -781},  {183, -781},  {184, -781},
    {185, -781},  {186, -781},  {187, -781},  {188, -781},  {189, -781},
    {190, -781},  {191, -781},  {192, -781},  {193, -781},  {194, -781},
    {195, -781},  {196, -781},  {197, -781},  {198, -781},  {199, -781},
    {200, -781},  {201, -781},  {202, -781},  {203, -781},  {204, -781},
    {205, -781},  {206, -781},  {207, -781},  {208, -781},  {209, -781},
    {210, -781},  {211, -781},  {212, -781},  {213, -781},  {214, -781},
    {215, -781},  {216, -781},  {217, -781},  {218, -781},  {219, -781},

    {220, -781},  {221, -781},  {222, -781},  {223, -781},  {224, -781},
    {225, -781},  {226, -781},  {227, -781},  {228, -781},  {229, -781},
    {230, -781},  {231, -781},  {232, -781},  {233, -781},  {234, -781},
    {235, -781},  {236, -781},  {237, -781},  {238, -781},  {239, -781},
    {240, -781},  {241, -781},  {242, -781},  {243, -781},  {244, -781},
    {245, -781},  {246, -781},  {247, -781},  {248, -781},  {249, -781},
    {250, -781},  {251, -781},  {252, -781},  {253, -781},  {254, -781},
    {255, -781},  {0, 0},       {257, 14},    {1, 0},
};

static const struct yy_trans_info *yy_start_state_list[3] = {
    &yy_transition[1], &yy_transition[3], &yy_transition[261],

};

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "tok.l"
#line 9 "tok.l"
#include "parser.h"
SymEngine::ParserBase::STYPE__ *dval;
using SymEngine::Parser;
#line 1194 "tok.cpp"
#line 1195 "tok.cpp"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals(void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy(void);

int yyget_debug(void);

void yyset_debug(int debug_flag);

YY_EXTRA_TYPE yyget_extra(void);

void yyset_extra(YY_EXTRA_TYPE user_defined);

FILE *yyget_in(void);

void yyset_in(FILE *_in_str);

FILE *yyget_out(void);

void yyset_out(FILE *_out_str);

int yyget_leng(void);

char *yyget_text(void);

int yyget_lineno(void);

void yyset_lineno(int _line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap(void);
#else
extern int yywrap(void);
#endif
#endif

#ifndef YY_NO_UNPUT

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char *, const char *, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char *);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void);
#else
static int input(void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                   \
    do {                                                                       \
        if (fwrite(yytext, (size_t)yyleng, 1, yyout)) {                        \
        }                                                                      \
    } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                        \
    errno = 0;                                                                 \
    while ((result = (int)read(fileno(yyin), buf, (yy_size_t)max_size)) < 0) { \
        if (errno != EINTR) {                                                  \
            YY_FATAL_ERROR("input in flex scanner failed");                    \
            break;                                                             \
        }                                                                      \
        errno = 0;                                                             \
        clearerr(yyin);                                                        \
    }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex(void);

#define YY_DECL int yylex(void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
    yy_state_type yy_current_state;
    char *yy_cp, *yy_bp;
    int yy_act;

    if (!(yy_init)) {
        (yy_init) = 1;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if (!(yy_start))
            (yy_start) = 1; /* first start state */

        if (!yyin)
            yyin = stdin;

        if (!yyout)
            yyout = stdout;

        if (!YY_CURRENT_BUFFER) {
            yyensure_buffer_stack();
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
        }

        yy_load_buffer_state();
    }

    {
#line 27 "tok.l"

#line 1397 "tok.cpp"

        while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
        {
            yy_cp = (yy_c_buf_p);

            /* Support of yytext. */
            *yy_cp = (yy_hold_char);

            /* yy_bp points to the position in yy_ch_buf of the start of
             * the current run.
             */
            yy_bp = yy_cp;

            yy_current_state = yy_start_state_list[(yy_start)];
        yy_match : {
            const struct yy_trans_info *yy_trans_info;

            YY_CHAR yy_c;

            for (yy_c = YY_SC_TO_UI(*yy_cp);
                 (yy_trans_info = &yy_current_state[yy_c])->yy_verify == yy_c;
                 yy_c = YY_SC_TO_UI(*++yy_cp)) {
                yy_current_state += yy_trans_info->yy_nxt;

                if (yy_current_state[-1].yy_nxt) {
                    (yy_last_accepting_state) = yy_current_state;
                    (yy_last_accepting_cpos) = yy_cp;
                }
            }
        }

        yy_find_action:
            yy_act = yy_current_state[-1].yy_nxt;

            YY_DO_BEFORE_ACTION;

        do_action: /* This label is used only to access EOF actions. */

            switch (yy_act) { /* beginning of action switch */
                case 0:       /* must back up */
                    /* undo the effects of YY_DO_BEFORE_ACTION */
                    *yy_cp = (yy_hold_char);
                    yy_cp = (yy_last_accepting_cpos) + 1;
                    yy_current_state = (yy_last_accepting_state);
                    goto yy_find_action;

                case 1:
                    YY_RULE_SETUP
#line 29 "tok.l"
                    {
                        return yytext[0];
                    }
                    YY_BREAK
                case 2:
                    YY_RULE_SETUP
#line 32 "tok.l"
                    {
                        return Parser::POW;
                    }
                    YY_BREAK
                case 3:
                    YY_RULE_SETUP
#line 35 "tok.l"
                    {
                        return Parser::LE;
                    }
                    YY_BREAK
                case 4:
                    YY_RULE_SETUP
#line 38 "tok.l"
                    {
                        return Parser::GE;
                    }
                    YY_BREAK
                case 5:
                    YY_RULE_SETUP
#line 41 "tok.l"
                    {
                        return Parser::EQ;
                    }
                    YY_BREAK
                case 6:
                    YY_RULE_SETUP
#line 44 "tok.l"
                    {
                        *dval = std::string(yytext);
                        return Parser::IDENTIFIER;
                    }
                    YY_BREAK
                case 7:
                    YY_RULE_SETUP
#line 48 "tok.l"
                    {
                        *dval = std::string(yytext);
                        return Parser::IMPLICIT_MUL;
                    }
                    YY_BREAK
                case 8:
                    YY_RULE_SETUP
#line 52 "tok.l"
                    {
                        *dval = std::string(yytext);
                        return Parser::NUMERIC;
                    }
                    YY_BREAK
                case 9:
/* rule 9 can match eol */
#line 57 "tok.l"
                case 10:
/* rule 10 can match eol */
#line 58 "tok.l"
                case 11:
                    /* rule 11 can match eol */
                    YY_RULE_SETUP
#line 58 "tok.l"
                    {
                    }
                    YY_BREAK
                case 12:
                    YY_RULE_SETUP
#line 60 "tok.l"
                    {
                    }
                    YY_BREAK
                case 13:
                    YY_RULE_SETUP
#line 62 "tok.l"
                    ECHO;
                    YY_BREAK
#line 1532 "tok.cpp"
                case YY_STATE_EOF(INITIAL):
                    yyterminate();

                case YY_END_OF_BUFFER: {
                    /* Amount of text matched not including the EOB char. */
                    int yy_amount_of_matched_text
                        = (int)(yy_cp - (yytext_ptr)) - 1;

                    /* Undo the effects of YY_DO_BEFORE_ACTION. */
                    *yy_cp = (yy_hold_char);
                    YY_RESTORE_YY_MORE_OFFSET

                    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status
                        == YY_BUFFER_NEW) {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status
                            = YY_BUFFER_NORMAL;
                    }

                    /* Note that here we test for yy_c_buf_p "<=" to the
                     * position
                     * of the first EOB in the buffer, since yy_c_buf_p will
                     * already have been incremented past the NUL character
                     * (since all states make transitions on EOB to the
                     * end-of-buffer state).  Contrast this with the test
                     * in input().
                     */
                    if ((yy_c_buf_p)
                        <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(
                               yy_n_chars)]) { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state();

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans(yy_current_state);

                        yy_bp = (yytext_ptr) + YY_MORE_ADJ;

                        if (yy_next_state) {
                            /* Consume the NUL. */
                            yy_cp = ++(yy_c_buf_p);
                            yy_current_state = yy_next_state;
                            goto yy_match;
                        }

                        else {
                            yy_cp = (yy_c_buf_p);
                            goto yy_find_action;
                        }
                    }

                    else
                        switch (yy_get_next_buffer()) {
                            case EOB_ACT_END_OF_FILE: {
                                (yy_did_buffer_switch_on_eof) = 0;

                                if (yywrap()) {
                                    /* Note: because we've taken care in
                                     * yy_get_next_buffer() to have set up
                                     * yytext, we can now set up
                                     * yy_c_buf_p so that if some total
                                     * hoser (like flex itself) wants to
                                     * call the scanner after we return the
                                     * YY_NULL, it'll still work - another
                                     * YY_NULL will get returned.
                                     */
                                    (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                                    yy_act = YY_STATE_EOF(YY_START);
                                    goto do_action;
                                }

                                else {
                                    if (!(yy_did_buffer_switch_on_eof))
                                        YY_NEW_FILE;
                                }
                                break;
                            }

                            case EOB_ACT_CONTINUE_SCAN:
                                (yy_c_buf_p)
                                    = (yytext_ptr) + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state();

                                yy_cp = (yy_c_buf_p);
                                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                                goto yy_match;

                            case EOB_ACT_LAST_MATCH:
                                (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE
                                                    ->yy_ch_buf[(yy_n_chars)];

                                yy_current_state = yy_get_previous_state();

                                yy_cp = (yy_c_buf_p);
                                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                    break;
                }

                default:
                    YY_FATAL_ERROR(
                        "fatal flex scanner internal error--no action found");
            } /* end of action switch */
        }     /* end of scanning one token */
    }         /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(void)
{
    char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
    char *source = (yytext_ptr);
    int number_to_move, i;
    int ret_val;

    if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
        YY_FATAL_ERROR(
            "fatal flex scanner internal error--end of buffer missed");

    if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer
        == 0) { /* Don't try to fill the buffer, so this is an EOF. */
        if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1) {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
        }

        else {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
        }
    }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)-1);

    for (i = 0; i < number_to_move; ++i)
        *(dest++) = *(source++);

    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

    else {
        int num_to_read
            = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

        while (num_to_read
               <= 0) { /* Not enough room in the buffer - grow it. */

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

            int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

            if (b->yy_is_our_buffer) {
                int new_size = b->yy_buf_size * 2;

                if (new_size <= 0)
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char *)
                    /* Include room in for 2 EOB chars. */
                    yyrealloc((void *)b->yy_ch_buf,
                              (yy_size_t)(b->yy_buf_size + 2));
            } else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = NULL;

            if (!b->yy_ch_buf)
                YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

            (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read
                = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
        }

        if (num_to_read > YY_READ_BUF_SIZE)
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                 (yy_n_chars), num_to_read);

        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

    if ((yy_n_chars) == 0) {
        if (number_to_move == YY_MORE_ADJ) {
            ret_val = EOB_ACT_END_OF_FILE;
            yyrestart(yyin);
        }

        else {
            ret_val = EOB_ACT_LAST_MATCH;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
        }
    }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    if (((yy_n_chars) + number_to_move)
        > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
        /* Extend the array by 50%, plus the number we really need. */
        int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *)yyrealloc(
            (void *)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size);
        if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
            YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
        /* "- 2" to take care of EOB's */
        YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
    }

    (yy_n_chars) += number_to_move;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1]
        = YY_END_OF_BUFFER_CHAR;

    (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

    return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state(void)
{
    yy_state_type yy_current_state;
    char *yy_cp;

    yy_current_state = yy_start_state_list[(yy_start)];

    for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp) {
        yy_current_state
            += yy_current_state[(*yy_cp ? YY_SC_TO_UI(*yy_cp) : 256)].yy_nxt;
        if (yy_current_state[-1].yy_nxt) {
            (yy_last_accepting_state) = yy_current_state;
            (yy_last_accepting_cpos) = yy_cp;
        }
    }

    return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
{
    int yy_is_jam;
    char *yy_cp = (yy_c_buf_p);

    int yy_c = 256;
    const struct yy_trans_info *yy_trans_info;

    yy_trans_info = &yy_current_state[(unsigned int)yy_c];
    yy_current_state += yy_trans_info->yy_nxt;
    yy_is_jam = (yy_trans_info->yy_verify != yy_c);

    if (!yy_is_jam) {
        if (yy_current_state[-1].yy_nxt) {
            (yy_last_accepting_state) = yy_current_state;
            (yy_last_accepting_cpos) = yy_cp;
        }
    }

    return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void)
#else
static int input(void)
#endif

{
    int c;

    *(yy_c_buf_p) = (yy_hold_char);

    if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR) {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
            /* This was really a NUL. */
            *(yy_c_buf_p) = '\0';

        else { /* need more input */
            int offset = (int)((yy_c_buf_p) - (yytext_ptr));
            ++(yy_c_buf_p);

            switch (yy_get_next_buffer()) {
                case EOB_ACT_LAST_MATCH:
                    /* This happens because yy_g_n_b()
                     * sees that we've accumulated a
                     * token and flags that we need to
                     * try matching the token before
                     * proceeding.  But for input(),
                     * there's no matching to consider.
                     * So convert the EOB_ACT_LAST_MATCH
                     * to EOB_ACT_END_OF_FILE.
                     */

                    /* Reset buffer status. */
                    yyrestart(yyin);

                /*FALLTHROUGH*/

                case EOB_ACT_END_OF_FILE: {
                    if (yywrap())
                        return 0;

                    if (!(yy_did_buffer_switch_on_eof))
                        YY_NEW_FILE;
#ifdef __cplusplus
                    return yyinput();
#else
                    return input();
#endif
                }

                case EOB_ACT_CONTINUE_SCAN:
                    (yy_c_buf_p) = (yytext_ptr) + offset;
                    break;
            }
        }
    }

    c = *(unsigned char *)(yy_c_buf_p); /* cast for 8-bit char's */
    *(yy_c_buf_p) = '\0';               /* preserve yytext */
    (yy_hold_char) = *++(yy_c_buf_p);

    return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE *input_file)
{

    if (!YY_CURRENT_BUFFER) {
        yyensure_buffer_stack();
        YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_init_buffer(YY_CURRENT_BUFFER, input_file);
    yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
{

    /* TODO. We should be able to replace this entire function body
     * with
     *		yypop_buffer_state();
     *		yypush_buffer_state(new_buffer);
     */
    yyensure_buffer_stack();
    if (YY_CURRENT_BUFFER == new_buffer)
        return;

    if (YY_CURRENT_BUFFER) {
        /* Flush out information for old buffer. */
        *(yy_c_buf_p) = (yy_hold_char);
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

    YY_CURRENT_BUFFER_LVALUE = new_buffer;
    yy_load_buffer_state();

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    (yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state(void)
{
    (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
    (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
    yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
    (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c
 * YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size)
{
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
    if (!b)
        YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char *)yyalloc((yy_size_t)(b->yy_buf_size + 2));
    if (!b->yy_ch_buf)
        YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_is_our_buffer = 1;

    yy_init_buffer(b, file);

    return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void yy_delete_buffer(YY_BUFFER_STATE b)
{

    if (!b)
        return;

    if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
        YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

    if (b->yy_is_our_buffer)
        yyfree((void *)b->yy_ch_buf);

    yyfree((void *)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE *file)

{
    int oerrno = errno;

    yy_flush_buffer(b);

    b->yy_input_file = file;
    b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER) {
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

    b->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;

    errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void yy_flush_buffer(YY_BUFFER_STATE b)
{
    if (!b)
        return;

    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if (b == YY_CURRENT_BUFFER)
        yy_load_buffer_state();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer)
{
    if (new_buffer == NULL)
        return;

    yyensure_buffer_stack();

    /* This block is copied from yy_switch_to_buffer. */
    if (YY_CURRENT_BUFFER) {
        /* Flush out information for old buffer. */
        *(yy_c_buf_p) = (yy_hold_char);
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

    /* Only push if top exists. Otherwise, replace top. */
    if (YY_CURRENT_BUFFER)
        (yy_buffer_stack_top)++;
    YY_CURRENT_BUFFER_LVALUE = new_buffer;

    /* copied from yy_switch_to_buffer. */
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state(void)
{
    if (!YY_CURRENT_BUFFER)
        return;

    yy_delete_buffer(YY_CURRENT_BUFFER);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    if ((yy_buffer_stack_top) > 0)
        --(yy_buffer_stack_top);

    if (YY_CURRENT_BUFFER) {
        yy_load_buffer_state();
        (yy_did_buffer_switch_on_eof) = 1;
    }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(void)
{
    yy_size_t num_to_alloc;

    if (!(yy_buffer_stack)) {

        /* First allocation is just for 2 elements, since we don't know if this
         * scanner will even need a stack. We use 2 instead of 1 to avoid an
         * immediate realloc on the next call.
         */
        num_to_alloc
            = 1; /* After all that talk, this was set to 1 anyways... */
        (yy_buffer_stack) = (struct yy_buffer_state **)yyalloc(
            num_to_alloc * sizeof(struct yy_buffer_state *));
        if (!(yy_buffer_stack))
            YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

        memset((yy_buffer_stack), 0,
               num_to_alloc * sizeof(struct yy_buffer_state *));

        (yy_buffer_stack_max) = num_to_alloc;
        (yy_buffer_stack_top) = 0;
        return;
    }

    if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1) {

        /* Increase the buffer to prepare for a possible push. */
        yy_size_t grow_size = 8 /* arbitrary grow size */;

        num_to_alloc = (yy_buffer_stack_max) + grow_size;
        (yy_buffer_stack) = (struct yy_buffer_state **)yyrealloc(
            (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state *));
        if (!(yy_buffer_stack))
            YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

        /* zero only the new slots.*/
        memset((yy_buffer_stack) + (yy_buffer_stack_max), 0,
               grow_size * sizeof(struct yy_buffer_state *));
        (yy_buffer_stack_max) = num_to_alloc;
    }
}

/** Setup the input buffer state to scan directly from a user-specified
 * character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char *base, yy_size_t size)
{
    YY_BUFFER_STATE b;

    if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR
        || base[size - 1] != YY_END_OF_BUFFER_CHAR)
        /* They forgot to leave room for the EOB's. */
        return NULL;

    b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
    if (!b)
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

    b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = NULL;
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = YY_BUFFER_NEW;

    yy_switch_to_buffer(b);

    return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char *yystr)
{

    return yy_scan_bytes(yystr, (int)strlen(yystr));
}

/** Setup the input buffer state to scan the given bytes. The next call to
 * yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char *yybytes, int _yybytes_len)
{
    YY_BUFFER_STATE b;
    char *buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n = (yy_size_t)(_yybytes_len + 2);
    buf = (char *)yyalloc(n);
    if (!buf)
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

    for (i = 0; i < _yybytes_len; ++i)
        buf[i] = yybytes[i];

    buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer(buf, n);
    if (!b)
        YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char *msg)
{
    fprintf(stderr, "%s\n", msg);
    exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                              \
    do {                                                                       \
        /* Undo effects of setting up yytext. */                               \
        int yyless_macro_arg = (n);                                            \
        YY_LESS_LINENO(yyless_macro_arg);                                      \
        yytext[yyleng] = (yy_hold_char);                                       \
        (yy_c_buf_p) = yytext + yyless_macro_arg;                              \
        (yy_hold_char) = *(yy_c_buf_p);                                        \
        *(yy_c_buf_p) = '\0';                                                  \
        yyleng = yyless_macro_arg;                                             \
    } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno(void)
{

    return yylineno;
}

/** Get the input stream.
 *
 */
FILE *yyget_in(void)
{
    return yyin;
}

/** Get the output stream.
 *
 */
FILE *yyget_out(void)
{
    return yyout;
}

/** Get the length of the current token.
 *
 */
int yyget_leng(void)
{
    return yyleng;
}

/** Get the current token.
 *
 */

char *yyget_text(void)
{
    return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno(int _line_number)
{

    yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE *_in_str)
{
    yyin = _in_str;
}

void yyset_out(FILE *_out_str)
{
    yyout = _out_str;
}

int yyget_debug(void)
{
    return yy_flex_debug;
}

void yyset_debug(int _bdebug)
{
    yy_flex_debug = _bdebug;
}

static int yy_init_globals(void)
{
    /* Initialization is the same as for the non-reentrant scanner.
 * This function is called from yylex_destroy(), so don't allocate here.
 */

    (yy_buffer_stack) = NULL;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = NULL;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(void)
{

    /* Pop the buffer stack, destroying each element. */
    while (YY_CURRENT_BUFFER) {
        yy_delete_buffer(YY_CURRENT_BUFFER);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        yypop_buffer_state();
    }

    /* Destroy the stack itself. */
    yyfree((yy_buffer_stack));
    (yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the
     * next time
     * yylex() is called, initialization will occur. */
    yy_init_globals();

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char *s1, const char *s2, int n)
{

    int i;
    for (i = 0; i < n; ++i)
        s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char *s)
{
    int n;
    for (n = 0; s[n]; ++n)
        ;

    return n;
}
#endif

void *yyalloc(yy_size_t size)
{
    return malloc(size);
}

void *yyrealloc(void *ptr, yy_size_t size)
{

    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return realloc(ptr, size);
}

void yyfree(void *ptr)
{
    free((char *)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 62 "tok.l"
